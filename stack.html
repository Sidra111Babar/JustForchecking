<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="assets/cppImg.png">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
    <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
    <script src="dist/mutiFileReference.js"></script>
    <title>Stack</title>
</head>
<body>
     <style>   
            .darkCode-mode {
                background-color: #000000;
            }
            .code-container {
                background-color: #282C34;
                border: 2px solid #61dafb;
                border-radius: 10px;
                padding: 20px;
                max-width: 600px;
                color: white;
                overflow-x: auto;
                font-family: 'Courier New', Courier, monospace;
            }
            /* Single Linked List Page */
            .dark-mode .SingleLinkedListPage{
                background-color: #282C34;
            }
            .dark-mode .SingleLinkedListPage{
                color: white;
            }
     </style>
         <nav class="navbar navbar-expand-lg d-flex firstNavBar border-bottom border-tertiary">
            <div class="container-fluid">
            <a class="navbar-brand fs-4 fw-bold firstnavHeading" href="#"><img src="assets/cppdsaImg (1).png" alt="" style="width: 30px; height: 30px; border-radius: 50%;"></a>
            <div class="d-flex gap-3 firstNavIcons">
                <i class='bx bx-moon fs-4' id="darkLightIcon"></i>
                    <!-- Button trigger modal -->
                <!-- <i  class='bx bx-user fs-4' data-bs-toggle="modal" data-bs-target="#loginFormModal"></i>   -->
                <!-- Modal -->
                <div class="modal fade " id="loginFormModal" tabindex="-1" aria-labelledby="loginFormModalLabel" aria-hidden="true">
                    <div class="modal-dialog">
                    <div class="modal-content loginSignUpFormModal" style=" color: rgb(9, 171, 236);">
                        <div class="modal-header">
                        <h1 class="modal-title fs-5" id="loginFormModalLabel">SignUp</h1>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <form id="signupForm">
                                <div class="mb-3">
                                  <label for="name" class="form-label">Name</label>
                                  <input type="text" class="form-control" id="name" required>
                                </div>
                                <div class="mb-3">
                                  <label for="exampleInputEmail1" class="form-label">Email address</label>
                                  <input type="email" class="form-control" id="email" aria-describedby="emailHelp" required>
                                </div>
                                <div class="mb-3">
                                  <label for="password" class="form-label">Password</label>
                                  <input type="password" class="form-control" id="password" required>
                                </div>
                                <div class="mb-3">
                                  <label for="confirmPassword" class="form-label">Confirm Password</label>
                                  <input type="password" class="form-control" id="confirmPassword" required>
                                </div>
                                <div class="d-flex justify-content-center">
                                  <button type="submit" class="btn btn-primary">Sign Up</button>
                                </div>
                                <div id="loginPrompt" class="text-center mt-3"></div>
                              </form>
                              <div id="loginForm" class="text-center">
                                <p>Already registered? <a href="#" id="showLogin">Login</a></p>
                              </div>                              
                        </div>
                    </div>
                    </div>
                </div>
            </div>
            <div class="" id="navbarSupportedContent d-flex flex-row gap-3">
                <div>
                    <form class="d-flex" role="search" id="searchForm" onsubmit="handleSearch(event)">
                        <input type="text" id="searchInput" class="form-control me-2" type="search" placeholder="Search" aria-label="Search">
                        <button class="btn searchBtn" type="submit">Search</button>
                    </form>
                </div>
            </div>
            </div>
        </nav>
        <div id="navbar" style="position: sticky; top:0; z-index: 1000;"></div>
        <script>loadContent('navbar.html', 'navbar');</script>
        <div id="sidebar"></div>
        <script>loadContent('codeSidebar.html', 'sidebar');</script>
       <div class="container-fluid SingleLinkedListPage">
            <div class="row">
                <div class="col-md-3 p-5 ">
                </div>
                <div class="col-md-9 pb-5">
                    <h1 class="text-primary">Stack</h1>
                    <p>A stack in C++ is a data structure that follows the Last In, First Out (LIFO) principle, where the last element added is the first one to be removed. The C++ Standard Template Library (STL) provides a ready-to-use stack class template, which simplifies the implementation of stack operations like push, pop, top, and size.</p>
                    <h2 class="fw-bold text-primary">Implementation Methods</h2>
                        <div><span class="fs-2 fw-bold">1. Stack Using Array</span><p>A stack can be implemented using an array by keeping track of the top index, which represents the top element of the stack. The array-based implementation of a stack is simple, but it has a limitation: the size of the stack is fixed, meaning the maximum number of elements is predetermined when the stack is created.</p>
                            <h3 class="">Concepts</h3>
                            <ul>
                                <li><span class="fw-bold">Fixed Size </span>The size of the array needs to be declared in advance.</li>
                                <li><span class="fw-bold">Top Index </span> The top variable keeps track of the index of the last inserted element.</li>
                                <li><span class="fw-bold">Overflow Condition </span> When the stack is full and you try to push a new element, it's called stack overflow.</li>
                                <li><span class="fw-bold">Underflow Condition </span> When you try to pop an element from an empty stack, it's called stack underflow.</li>
                            </ul>
                            <h3>Advantages</h3>
                            <ul>
                                <li>Easy to implement</li>
                                <li>Efficient access because of direct indexing into the array.</li>
                            </ul>
                            <h3 >Disadvantages</h3>
                            <ul>
                                <li>Fixed size, so it may not be able to handle a dynamic number of elements.</li>
                                <li>Wastes memory if the stack is not fully utilized</li>
                            </ul>
                        </div>
                        <div><span class="fw-bold fs-2">2.  Stack Using Linked List</span> <p>A stack can also be implemented using a linked list, where each node contains two fields: the data and a pointer to the next node. The benefit of using a linked list is that the stack size can grow dynamically, and there is no need to worry about overflow unless memory is exhausted</p>
                        <h3>Concepts</h3>
                        <ul>
                            <li><span class="fw-bold">Dynamic Size</span>The stack grows or shrinks as needed.</li>
                            <li><span class="fw-bold">Top Pointer</span>The top pointer points to the node at the top of the stack.</li>
                            <li><span class="fw-bold">No Overflow</span>Since the stack size is dynamic, overflow occurs only when the system runs out of memory.</li>
                        </ul>
                        <h3>Advantages</h3>
                        <ul>
                            <li>Dynamic size allows the stack to grow and shrink as necessary.</li>
                            <li>No need to define the stack's maximum size in advance.</li>
                        </ul>
                        <h3>Disadvantages</h3>
                        <ul>
                            <li>Every node requires additional memory for the pointer.</li>
                            <li>Slower access time compared to array-based stack because each node must be accessed via pointer traversal.</li>
                        </ul> 
                        </div>
                    <div class="table-responsive">
                        <table class="table table-striped table-hover table-bordered border-primary table-primary">
                          <thead>
                            <tr>
                              <th scope="col">Feature</th>
                              <th scope="col">Array-Based Stack</th>
                              <th scope="col">Linked List-Based Stack</th>
                            </tr>
                          </thead>
                          <tbody>
                            <tr>
                              <th scope="row">Size</th>
                              <td>Fixed size; must be known in advance.</td>
                              <td>Dynamic; grows and shrinks as needed.</td>
                            </tr>
                            <tr>
                              <th scope="row">Memory Utilization</th>
                              <td>Efficient memory usage if the size is known.</td>
                              <td>May use more memory due to pointer overhead.</td>
                            </tr>
                            <tr>
                              <th scope="row">Overflow</th>
                              <td>Can occur if the array is full.</td>
                              <td>No overflow (unless out of memory).</td>
                            </tr>
                            <tr>
                              <th scope="row">Underflow</th>
                              <td>Can occur if the stack is empty.</td>
                              <td>Can occur if the stack is empty.</td>
                            </tr>
                            <tr>
                              <th scope="row">Access Speed</th>
                              <td>Fast (constant time) as elements are indexed directly.</td>
                              <td>Slower, as nodes are accessed sequentially.</td>
                            </tr>
                            <tr>
                              <th scope="row">Implementation</th>
                              <td>Simple and direct to implement.</td>
                              <td>Slightly more complex due to dynamic memory.</td>
                            </tr>
                            <tr>
                              <th scope="row">Memory Efficiency</th>
                              <td>Can waste memory if stack is underutilized.</td>
                              <td>Uses exactly as much memory as needed.</td>
                            </tr>
                          </tbody>
                        </table>
                      </div>
                    <h1>Operations Using Array</h1>
                    <ul>
                        <li>Push</li>
                        <li>Pop</li>
                        <li>isEmpty</li>
                        <li>Peek</li>
                        <li>Display</li>
                    </ul>
                    <div class="code-container">
                         <div>
                             <i class='bx bx-copy text-dark bg-light p-2 rounded' id="copyIcon24"></i>
                             <i class='bx bx-moon text-dark bg-light p-2 rounded lightDarkIconForCode' id="lightDarkIcon24"></i>
                         </div>
                        <pre class="mt-2"><code class="language-cpp" id="SimpleNodeCode24">
#include &lt;iostream&gt;
    using namespace std;   
    class Stack {
    private:
        int top;
        int* array;
        int capacity;
    public:
        // Constructor  
        Stack(int size) : top(-1), capacity(size) {
            array = new int[capacity];         // dynamic memory allocation to array
        }
    
        // Destructor to free dynamically allocated memory (when used new keyword, it is necessary to use delete keyword to free memory)
        ~Stack() {
            delete[] array;
        } 
        bool isEmpty() {
            return top == -1;     // index start from 0 so -1 is empty(use to make logic)
        }    
        void push(int value) {
            if (top == capacity - 1) {      // if stack is full element cannot add 
                cout << "Stack overflow! Cannot push more elements." << endl;
                return;
            }
            array[++top] = value;
            cout << value << " pushed onto the stack." << endl;
        } 
    
        void pop() {
            if (isEmpty()) {     // or top == -1 (this logic can also be used)
                cout << "Stack underflow! Cannot pop from an empty stack." << endl;
                return;
            }
            cout << array[top--] << " popped from the stack." << endl;
        }  
        int peek() {
            if (isEmpty()) {
                cout << "Stack is empty." << endl;
                return -1; 
            }
            return array[top];
        }
        void display(int size){
                for(int i = 0; i < size; i++){
                    cout << "Element " << i+1 << " is " << array[i] << endl; 
                }
        }
    };
    
    int main() {
        int size = 3;
        // Create a stack with a specified size
        Stack myStack(size);
        myStack.push(10);
        myStack.push(20);
        myStack.push(30);
        cout << "All the Elements of stack" << endl;
        myStack.display(size);
        cout << "Top element: " << myStack.peek() << endl;  
        myStack.pop();
        myStack.pop();
        myStack.pop();
        // Now stack is empty
        myStack.pop();
        
    
        return 0;
    }
    </code></pre>
                    </div>
                    <div>
                        <h1>Stack Using Linked List </h1>
                        <ul>
                            <li>Push</li>
                            <li>Pop</li>
                            <li>isEmpty</li>
                            <li>Display</li>
                        </ul>
                        <div class="code-container">
                            <div>
                                <i class='bx bx-copy text-dark bg-light p-2 rounded' id="copyIcon25"></i>
                                <i class='bx bx-moon text-dark bg-light p-2 rounded lightDarkIconForCode' id="lightDarkIcon25"></i>
                            </div>
                           <pre class="mt-2"><code class="language-cpp" id="SimpleNodeCode25">
   #include &lt;iostream&gt;
    using namespace std;
    class Stack {
    private:
        class Node{
            public:
               int data;
               Node* next;
    
        Node(int data) {
            this->data = data;
            this->next = nullptr;
        }
            
        };
        Node* topNode;
    
    public:
        Stack() {
            topNode = nullptr;
        }
    
        void push(int data) {
            Node* newNode = new Node(data);   
            newNode->next = topNode;         
            topNode = newNode;               
        }
    
       void pop() {
        if (isEmpty()) {
            cout << "Stack is empty" << endl;
            return;
        }
        Node* temp = topNode; 
        topNode = topNode->next; 
        delete temp; 
        }
        
        void displayStack() {
        Node* current = topNode; 
        if (current == nullptr) {
            cout << "Stack is empty" << endl;
            return;
        }
        while (current != nullptr) {
            cout << current->data << " ";
            current = current->next;
        }
          cout << endl;
        }
    
    
    
        bool isEmpty() {
            return topNode == nullptr;
        }
    
        int top() {
            if (isEmpty()) {
                cout << "Stack is empty" << endl;
                return -1; 
            }
            return topNode->data;
        }
    };
    
    int main() {
        Stack stack;
    
        cout << "Is stack empty: " << (stack.isEmpty() ? "true" : "false") << endl; 
    
        stack.push(1);
        cout << stack.top() << " is pushed successfully " << endl;
        stack.push(2);
        cout << stack.top() << " is pushed successfully " << endl;
        stack.push(3);
        cout << stack.top() << " is pushed successfully " << endl;
        stack.push(4);
        cout << stack.top() << " is pushed successfully " << endl;
        stack.displayStack();
        cout << "Top element of the stack: " << stack.top() << endl;
        cout << stack.top() << " is popped successfully " << endl;
        stack.pop();
        cout << stack.top() << " is popped successfully " << endl;
        cout << endl;
       
        stack.pop();
        cout << endl;
    
        cout << "Top element of the stack: " << stack.top() << endl;
    
        cout << "Is stack empty: " << (stack.isEmpty() ? "true" : "false") << endl;
        stack.displayStack();
    
        return 0;
    }
    
       </code></pre>
                       </div>
                       <h1 class="py-3">Reverse String Using Stack(STL)</h1>
                       <div class="code-container">
                        <div>
                            <i class='bx bx-copy text-dark bg-light p-2 rounded' id="copyIcon26"></i>
                            <i class='bx bx-moon text-dark bg-light p-2 rounded lightDarkIconForCode' id="lightDarkIcon26"></i>
                        </div>
                       <pre class="mt-2"><code class="language-cpp" id="SimpleNodeCode26">
    #include &lt;iostream&gt;
    #include &lt;stack&gt;
    #include &lt;string&gt;
    using namespace std;
    int main() {
        string userInput;
        cout << "Enter a string: ";
        getline(cin, userInput);
        stack&lt;char&gt; charStack;     
        for (char c : userInput) {            
            charStack.push(c);          
        }
        // Pop characters from the stack to reverse the string
        cout << "Reversed string: ";
        while (!charStack.empty()) {
            cout << charStack.top();
            charStack.pop();
        }
        cout << endl;
        return 0;
    }
   </code></pre>
                     </div>
                        <h1 class="py-3">Postfix Evaluation Using Stack</h1>
                        <div class="code-container">
                            <div>
                                <i class='bx bx-copy text-dark bg-light p-2 rounded' id="copyIcon27"></i>
                                <i class='bx bx-moon text-dark bg-light p-2 rounded lightDarkIconForCode' id="lightDarkIcon27"></i>
                            </div>
                           <pre class="mt-2"><code class="language-cpp" id="SimpleNodeCode27">
#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std; 
// Function to evaluate Postfix expression
int evaluate_postfixExpression(string postfix) {
    stack&lt;int&gt; intstack;
    for (int i = 0; i < postfix.length(); i++) {
        if (isdigit(postfix[i])) {
            intstack.push(postfix[i] - '0'); // Convert char to int
        } else {
            int op2 = intstack.top();
            intstack.pop();
            int op1 = intstack.top(); // Corrected the order of operands
            intstack.pop();
            char oper = postfix[i]; // Operator
            int result;
            switch (oper) {
                case '+':
                    result = op1 + op2;
                    break;
                case '-':
                    result = op1 - op2;
                    break;
                case '*':
                    result = op1 * op2;
                    break;
                case '/':
                    result = op1 / op2;
                    break;
                default:
                    cout << "Invalid operator encountered." << endl;
                    return -1; // Return error code
            }
            intstack.push(result); // Push result onto stack
        }
    }
    return intstack.top(); // Return final result
}

int main() {
    string postfix = "53+62/*35*+";
    cout << "Postfix expression: " << postfix << endl;
    cout << "Result of evaluation: " << evaluate_postfixExpression(postfix);
    postfix = "231*+9-";
    cout << "Postfix expression: " << postfix << endl;
    cout << "Result of evaluation: " << evaluate_postfixExpression(postfix);    
    return 0;
}
       </code></pre>
                       </div>
                    <div>
                        <h2>Stack Operations or Applications</h2>
                        <ul>
                              <li>Are Brackets Balanced</li>
                              <li>Infix to Postfix</li>
                              <li>Infix to Prefix</li>
                              <li>Prefix to Postfix</li>
                              <li>Prefix to Infix</li>
                              <li>Postfix to Infix</li>
                              <li>Postfix to Prefix</li>
                        </ul>
                        <div class="code-container">
                            <div>
                                <i class='bx bx-copy text-dark bg-light p-2 rounded' id="copyIcon28"></i>
                                <i class='bx bx-moon text-dark bg-light p-2 rounded lightDarkIconForCode' id="lightDarkIcon28"></i>
                            </div>
                           <pre class="mt-2"><code class="language-cpp" id="SimpleNodeCode28">
#include &lt;iostream&gt;
#include &lt;stack&gt;
 using namespace std;
    bool areBracketsBalanced(string expr) {
        // Declare a stack to hold the previous brackets   
        stack&lt;char&gt; temp;
        
        for (int i = 0; i < expr.length(); i++) {
            if (expr[i] == '(' || expr[i] == '{' || expr[i] == '[') {
                // If the current character is an opening bracket, push it onto the stack
                temp.push(expr[i]);  
            }
            else if (!temp.empty() && ((temp.top() == '(' && expr[i] == ')') ||
                                       (temp.top() == '{' && expr[i] == '}') ||
                                       (temp.top() == '[' && expr[i] == ']'))) {
                // If we found any complete pair of brackets, then pop
                temp.pop();
            }
            else {
                // If the current character is not a closing bracket or there's no matching opening bracket in the stack,
                // push the current character onto the stack
                temp.push(expr[i]);
            }
        }
        
        // If stack is empty return true, otherwise return false
        return temp.empty();
    }
    
    int precedence(char ch) {
        if (ch == '^') {
            return 3;
        } else if (ch == '*' || ch == '/') {
            return 2;
        } else if (ch == '+' || ch == '-') {
            return 1;
        } else {
            return -1;
        }
    }
    
    void infixToPostfix_Conversion(string infix) {
        string postfix = "";
        stack&lt;char&gt; charstack;
        for (int i = 0; i < infix.length(); i++) 
        {    
             
            if (isalnum(infix[i])) { // isalnum is a built-in function that checks if the character is an alphabet or digit
               
                postfix += infix[i]; // if infix at the ith index is a character or digit, store it into the postfix expression
                
            } else if (infix[i] == '(') { // if infix at the ith index has an opening bracket, then push it into the stack because parentheses have the highest precedence
               
                charstack.push(infix[i]);
            
            } else if (infix[i] == ')') { // if infix at the ith index has a closing bracket, then pop all opening brackets
                while (charstack.top() != '(') {
                
                    postfix += charstack.top();
                    
                    charstack.pop();
                }
                charstack.pop(); // pop '('
            } else { // If it's an operator
                while (!charstack.empty() && precedence(infix[i]) <= precedence(charstack.top())) {
                    postfix += charstack.top();
                   
                    charstack.pop(); 
                    
                }
                charstack.push(infix[i]); // Push the current operator onto the stack
                
            }
        }
        
        // After processing the infix expression, empty the stack and append its contents to the postfix expression
        while (!charstack.empty())
        {
            postfix += charstack.top();
            charstack.pop();
        }
        cout << "Postfix: " << postfix << endl;
    }
    void infixto_prefix(string infix) {
        string prefix;
        stack&lt;char&gt; charstack;
       
        for (int i = infix.length() - 1; i >= 0; i--) {
        
            if (isalnum(infix[i])) {
                prefix = infix[i] + prefix;
                
            } else if (infix[i] == ')') {
                charstack.push(infix[i]);
               
            } else if (infix[i] == '(') {
                while (!charstack.empty() && charstack.top() != ')') {
                    
                    prefix = charstack.top() + prefix;
                    
                    charstack.pop();
                }
                charstack.pop(); // Pop ')'
            } else {
                while (!charstack.empty() && precedence(infix[i]) < precedence(charstack.top())) {
                    
                    prefix = charstack.top() + prefix;
                    
                    charstack.pop();
                }
                charstack.push(infix[i]);
            }
        }
       
        while (!charstack.empty()) {
            prefix = charstack.top() + prefix;
           
            charstack.pop();
        }
    
        cout << "Prefix: " << prefix << endl;
    }
    
    bool isOperator(char c) {
        return (c == '+' || c == '-' || c == '*' || c == '/');
    }
    void prefixto_Postfix(string prefix) {
        stack&lt;string&gt; charstack;
        string postfix = "";
    
        for(int i = prefix.length() - 1; i >= 0; i--) {
            if(isalnum(prefix[i])) {
                string operand(1, prefix[i]); // Create a string from the operand character
                charstack.push(operand); // Push operands onto the stack
            } else if(isOperator(prefix[i])) {
                string operand1 = charstack.top();
                charstack.pop();
                string operand2 = charstack.top();
                charstack.pop();
    
                string result = operand1 + operand2 + prefix[i]; // Combine operands and operator
                charstack.push(result); // Push the intermediate result back to the stack
            }
        }
    
        postfix = charstack.top(); // The top of the stack will contain the final postfix expression
        cout << "Postfix Expression is " << postfix << endl;
    }
    string prefix_ToInfix(string prefix) {
      stack&lt;string&gt; s;
     
      // length of expression
      int length = prefix.size();
     
      // reading from right to left
      for (int i = length - 1; i >= 0; i--) {
     
        // check if symbol is operator
        if (isOperator(prefix[i])) {
     
          // pop two operands from stack
          string op1 = s.top();   s.pop();
          string op2 = s.top();   s.pop();
     
          // concat the operands and operator in between them
          string temp = "(" + op1 + prefix[i] + op2 + ")";
     
          // Push string temp back to stack
          s.push(temp);
        }
     
        // if symbol is an operand
        else {
     
          // push the operand to the stack
          s.push(string(1, prefix[i]));
        }
      }
     
      // Stack now contains the Infix expression
      return s.top();
    }
    bool isOperand(char x) {
        
        // This function checks if the character is an operand
        return isalnum(x);
    }
    
    string posttoInfix(string postfix) {
        stack&lt;string&gt; s;
    
        for (int i = 0; postfix[i] != '\0'; i++) {
            // Push if operands
            if (isOperand(postfix[i])) {
                
                string op = "";
                op += postfix[i];
                s.push(op);
            }
            // If operator
            else {
                string op1 = s.top();
                s.pop();
                string op2 = s.top();
                s.pop();
                // Concatenate strings directly
                s.push("(" + op2 + postfix[i] + op1 + ")");
            }
        }
    
        // There must be a single element
        // in stack now which is the required
        // infix.
        return s.top();
    }
    void post_to_pre()
    {
        //post to infix 
        // infix to prefix
        //or post to prefix directly
    }	
    
    
    int main() {
        string expr = "[{()}]";
    
        // Function call of Balanced Parenthesis
        if (areBracketsBalanced(expr))
            cout << "Balanced" << endl;
        else
            cout << "Not Balanced" << endl;
        // Function call for infix to postfix
        string infix = "a+b*(c^d-e)^(f+g*h)-i";
        infixToPostfix_Conversion(infix);
        // Function call for infix to prefix
        infix = "A+B*C+D";
        infixToPostfix_Conversion(infix);
        infix = "((A+B)-C*(D/E))+F";
        string iinfix;
        iinfix = "A*B+C/D";
        cout << "First infix to prefix " << endl;
        infixto_prefix(iinfix);
        iinfix = "(A-B/C)*(A/K-L)";
        cout << "2nd infix to prefix " << endl;
        infixto_prefix(iinfix);
        // Function call for prefix to postfix
        string prefix = "*+AB-CD";
        prefixto_Postfix(prefix);
        prefix = "*-A/BC-/AKL";
         prefixto_Postfix(prefix);
       //
        cout << "Infix from prefix " << prefix << " is " << prefix_ToInfix(prefix) << endl;
        string postfix;
        postfix = "abc++";
        cout << "Infix Expression is " << posttoInfix(postfix) << endl;
        postfix = "ab*c+";
        cout << "Infix Expression is " << posttoInfix(postfix) << endl;
         
        return 0;
    }
    
                           </code></pre>
                       </div>
                       <div>
                            <h3 class="py-3">Stack using Queue</h3>
                            <div class="code-container">
                                <div>
                                    <i class='bx bx-copy text-dark bg-light p-2 rounded' id="copyIcon29"></i>
                                    <i class='bx bx-moon text-dark bg-light p-2 rounded lightDarkIconForCode' id="lightDarkIcon29"></i>
                                </div>
                               <pre class="mt-2"><code class="language-cpp" id="SimpleNodeCode29">
    using namespace std;
    #include &lt;bits/stdc++.h&gt; 
    // -------------------------------------------------Stack using Queue-------------------------------------

    class Stack {
        // Two inbuilt queues
        queue&lt;int&gt;  q1, q2;
        
    public:
        void push(int x)
        {
            
            q2.push(x);                        
            
            while (!q1.empty()) {            
                q2.push(q1.front());         
                q1.pop();                     
            }
        
            
            queue&lt;int&gt;  q = q1;
            q1 = q2;
            q2 = q;
        }
        
        void pop()
        {
            // if no elements are there in q1
            if (q1.empty())
            return;
            q1.pop();
        }
        
        int top()
        {
            if (q1.empty())
            return -1;
            return q1.front();
        }
        
        int size() { return q1.size(); }
    };
        
    
    int main()
    {
        Stack s;
        s.push(1);
        s.push(2);
        s.push(3);
        // Now it is following Last in first out (LIFO)
        cout << "current size: " << s.size() << endl;
        cout << s.top() << endl;
        cout << s.top() << " Poped out\n";
        s.pop();
        cout << s.top() << endl;
        s.pop();
        cout << s.top() << endl;
        
        cout << "current size: " << s.size() << endl;
        return 0;
    }
                               </code></pre>
                       </div>
                </div>
            </div>
                </div>
                </div>
            </div>
       </div>
        <script>loadContent('footer.html', 'footer');</script>
        <div id="footer"></div>
        <script>loadContent('Up.html', 'quickUp');</script>
        <div id="quickUp"></div>
        <script src="js/searchFunctionlity.js"></script>
        <script src="dist/up.js"></script>
        <script src="dist/codeFunctionality.js"></script>
        <script src="dist/index.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/cpp.min.js"></script>
        <script>hljs.highlightAll();</script>
</body>
</html>