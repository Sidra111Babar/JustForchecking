<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="assets/cppImg.png">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
    <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
    <script src="dist/mutiFileReference.js"></script>
    <title>Double Linked List</title>
</head>
<body>
     <style>   
            .darkCode-mode {
                background-color: #000000;
            }
            .code-container {
                background-color: #282C34;
                border: 2px solid #61dafb;
                border-radius: 10px;
                padding: 20px;
                max-width: 600px;
                color: white;
                overflow-x: auto;
                font-family: 'Courier New', Courier, monospace;
            }
            /* Single Linked List Page */
            .dark-mode .SingleLinkedListPage{
                background-color: #282C34;
            }
            .dark-mode .SingleLinkedListPage{
                color: white;
            }
     </style>
         <nav class="navbar navbar-expand-lg d-flex firstNavBar border-bottom border-tertiary">
            <div class="container-fluid">
            <a class="navbar-brand fs-4 fw-bold firstnavHeading" href="#"><img src="assets/cppdsaImg (1).png" alt="" style="width: 30px; height: 30px; border-radius: 50%;"></a>
            <div class="d-flex gap-3 firstNavIcons">
                <i class='bx bx-moon fs-4' id="darkLightIcon"></i>
                    <!-- Button trigger modal -->
                <!-- <i  class='bx bx-user fs-4' data-bs-toggle="modal" data-bs-target="#loginFormModal"></i>   -->
                <!-- Modal -->
                <div class="modal fade " id="loginFormModal" tabindex="-1" aria-labelledby="loginFormModalLabel" aria-hidden="true">
                    <div class="modal-dialog">
                    <div class="modal-content loginSignUpFormModal" style=" color: rgb(9, 171, 236);">
                        <div class="modal-header">
                        <h1 class="modal-title fs-5" id="loginFormModalLabel">SignUp</h1>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <form id="signupForm">
                                <div class="mb-3">
                                  <label for="name" class="form-label">Name</label>
                                  <input type="text" class="form-control" id="name" required>
                                </div>
                                <div class="mb-3">
                                  <label for="exampleInputEmail1" class="form-label">Email address</label>
                                  <input type="email" class="form-control" id="email" aria-describedby="emailHelp" required>
                                </div>
                                <div class="mb-3">
                                  <label for="password" class="form-label">Password</label>
                                  <input type="password" class="form-control" id="password" required>
                                </div>
                                <div class="mb-3">
                                  <label for="confirmPassword" class="form-label">Confirm Password</label>
                                  <input type="password" class="form-control" id="confirmPassword" required>
                                </div>
                                <div class="d-flex justify-content-center">
                                  <button type="submit" class="btn btn-primary">Sign Up</button>
                                </div>
                                <div id="loginPrompt" class="text-center mt-3"></div>
                              </form>
                              <div id="loginForm" class="text-center">
                                <p>Already registered? <a href="#" id="showLogin">Login</a></p>
                              </div>                              
                        </div>
                    </div>
                    </div>
                </div>
            </div>
            <div class="" id="navbarSupportedContent d-flex flex-row gap-3">
                <div>
                    <form class="d-flex" role="search" id="searchForm" onsubmit="handleSearch(event)">
                        <input type="text" id="searchInput" class="form-control me-2" type="search" placeholder="Search" aria-label="Search">
                        <button class="btn searchBtn" type="submit">Search</button>
                    </form>
                </div>
            </div>
            </div>
        </nav>
        <div id="navbar" style="position: sticky; top:0; z-index: 1000;"></div>
        <script>loadContent('navbar.html', 'navbar');</script>
        <div id="sidebar"></div>
        <script>loadContent('codeSidebar.html', 'sidebar');</script>
      <div class="container-fluid SingleLinkedListPage">
            <div class="row">
                <div class="col-md-3 p-5 ">
                </div>
                <div class="col-md-9 pb-5">
                    <h1 class="text-primary">Doubly Linked List</h1>
                    <p>A Doubly Linked List (DLL) in C++ is a type of linked list where each node contains three fields: data, a pointer to the next node, and a pointer to the previous node. This structure allows traversal in both directions (forward and backward).</p>
                    <p>Each node contains three components:</p>
                    <p class="fw-bold">1. Data: The value stored in the node.</p>
                    <p class="fw-bold">2. prev: pointer to the previous node</p>
                    <p class="fw-bold">3. next: pointer to the next node</p>
                    <div class="code-container">
                         <div>
                            <div style="position: realtive; transition: 2s ease;" class="d-none copiedMessage">
                                <p  style="position: absolute; left: 40%; padding: 10px;clip-path: polygon(0% 15%, 0 0, 15% 0%, 85% 0%, 100% 0, 100% 15%, 100% 85%, 85% 85%, 63% 86%, 53% 100%, 42% 86%, 0% 85%); background-color: rgba(111, 44, 244, 0.603); color: white; border-radius: 5px;" >Copied!</p>
                            </div>
                            <div style="position: realtive; transition: 2s ease;" class="d-none notCopiedMessage">
                                <p  style="position: absolute; left: 40%; padding: 10px;clip-path: polygon(0% 15%, 0 0, 15% 0%, 85% 0%, 100% 0, 100% 15%, 100% 85%, 85% 85%, 63% 86%, 53% 100%, 42% 86%, 0% 85%); background-color: rgba(205, 22, 22, 0.427); color: white; border-radius: 5px;" >Not Copied!</p>
                            </div>
                             <i class='bx bx-copy text-dark bg-light p-2 rounded' id="copyIcon6"></i>
                             <i class='bx bx-moon text-dark bg-light p-2 rounded lightDarkIconForCode' id="lightDarkIcon6"></i>
                         </div>
                        <pre class="mt-2"><code class="language-cpp" id="SimpleNodeCode6">
    class DoublyLinkedList
    {
    private:
        class Node 
        {
        public:
            int data;
            Node * next;
            Node * prev;
            Node (int data)
            {
                this->data = data;
                next = prev = NULL;
            }
        };    
        Node* head;
        Node* tail;
    public:
        DoublyLinkedList(int data)
        {
            head = new Node (data);
            tail = head;
        }
    }
                        </code></pre>
                    </div>
                    
                    <div class="mt-2"> 
                         </ul>
                            <h2 class="text-primary">When to Use Doubly Linked List</h2>
                             <ol>
                                <li><span class="fw-bold">Bi-Directional Traversal::</span>
                                    <ul>
                                        <li>If your application requires frequent traversal in both directions (forward and backward), a DLL is ideal. The prev pointer allows easy backward traversal, which is not possible with a singly linked list (SLL).</li>
                                        <li><span class="fw-bold">Example:</span>A music player playlist where you can move to the next or previous song. You need efficient forward and backward navigation.
                                        </li>
                                    </ul>
                                </li>
                                <li><span class="fw-bold">Frequent Insertion and Deletion (especially at both ends):</span>
                                    <ul>
                                        <li>DLL provides efficient insertion and deletion of nodes at both ends (head and tail) or at any position in the list without having to traverse from the start. In contrast, an array or singly linked list might require shifting or traversing from the beginning.</li>
                                        <li> <span class="fw-bold">Example:</span>Browser history where you can add and remove URLs, and the user can navigate back and forth between pages.</li>
                                    </ul>
                                </li>
                                <li><span class="fw-bold">Undo Operations</span>
                                    <ul>
                                        <li>A doubly linked list is ideal for implementing undo functionality where you need to maintain a history of operations and traverse back and forth through this history.</li>
                                        <li> <span class="fw-bold">Example:</span>Text editors or applications that require undo-redo operations.</li>
                                    </ul>
                                </li>
                             </ol>
                             <h2 class="text-primary">When not to Use Doubly Linked List</h2>
                             <ol>
                                 <li><span class="fw-bold">Memory Overhead</span>
                                    <ul>
                                        <li><span class="fw-bold">Why Avoid</span>Each node in a DLL requires extra memory for an additional pointer (prev). In memory-constrained environments, this overhead can be costly.</li>
                                        <li><span class="fw-bold">Example</span>In systems with limited memory (e.g., embedded systems), you might prefer using a singly linked list or an array to save space.</li>
                                    </ul>
                                 </li>
                                 <li><span class="fw-bold">Simplicity</span>
                                    <ul>
                                        <li><span class="fw-bold">Why Avoid</span>If your use case only requires forward traversal and doesn’t benefit from backward traversal, a singly linked list (SLL) or even a simple array may be a better choice. A DLL adds complexity due to the additional pointers and the need to manage them correctly.</li>
                                        <li><span class="fw-bold">Example</span>A queue where you only need to process items in FIFO (First In, First Out) order.</li>
                                    </ul>
                                 </li>
                                 <li><span class="fw-bold">Cache or Array Optimization</span>
                                    <ul>
                                        <li><span class="fw-bold">Why Avoid</span>If you need random access (i.e., access to elements by index), an array or a dynamic array (like std::vector in C++) is more efficient. Linked lists, including DLLs, do not allow for direct access by index and require traversal from the head or tail.</li>
                                        <li><span class="fw-bold">Example</span>A scenario where frequent index-based access is needed, such as in sorting algorithms or binary search..</li>
                                    </ul>
                                 </li>
                             </ol>
                    </div>
                    <div>
                        <h2 class="text-primary">Frequent operations in Doubly Linked List</h2>
                        <p>Almost same as singly linked list except it provides forward anf backward traversal</p>
                        <ul>
                              <li>Insert at Front</li>
                              <li>Insert at End</li>
                              <li>Delete Node</li>
                              <li>Display Forward</li>
                              <li>Display Backward</li>
                        </ul>
                        <h2 class="text-primary">Operations in Doubly Linked List</h2>
                        <ul>
                            <li>Insertion at head</li>
                            <li>Insertion at tail</li>
                            <li>Deletion at head</li>
                            <li>Deletion at tail</li>
                            <li>Insertion at Specific Position</li>
                            <li>Deletion at Specific Position</li>
                            <li>Display Linked List</li>
                            <li>Display Reverse Linked List</li>
                            <li>Count in Linked List</li>
                        </ul>
                        <h2 class="my-3">First Method</h2>
                        <div class="code-container">
                            <div>
                                <div style="position: realtive; transition: 2s ease;" class="d-none copiedMessage">
                                    <p  style="position: absolute; left: 40%; padding: 10px;clip-path: polygon(0% 15%, 0 0, 15% 0%, 85% 0%, 100% 0, 100% 15%, 100% 85%, 85% 85%, 63% 86%, 53% 100%, 42% 86%, 0% 85%); background-color: rgba(111, 44, 244, 0.603); color: white; border-radius: 5px;" >Copied!</p>
                                </div>
                                <div style="position: realtive; transition: 2s ease;" class="d-none notCopiedMessage">
                                    <p  style="position: absolute; left: 40%; padding: 10px;clip-path: polygon(0% 15%, 0 0, 15% 0%, 85% 0%, 100% 0, 100% 15%, 100% 85%, 85% 85%, 63% 86%, 53% 100%, 42% 86%, 0% 85%); background-color: rgba(205, 22, 22, 0.427); color: white; border-radius: 5px;" >Not Copied!</p>
                                </div>
                                <i class='bx bx-copy text-dark bg-light p-2 rounded' id="copyIcon7"></i>
                                <i class='bx bx-moon text-dark bg-light p-2 rounded lightDarkIconForCode' id="lightDarkIcon7"></i>
                            </div>
                           <pre class="mt-2"><code class="language-cpp" id="SimpleNodeCode7">
#include &lt;iostream&gt;
using namespace std;
class DoublyLinkedList
{
private:
    class Node 
    {
    public:
        int data;
        Node * next;
        Node * prev;
        Node (int data)
        {
            this->data = data;
            next = prev = NULL;
        }
    };    
    Node* head;
    Node* tail;
public:
    DoublyLinkedList(int data)
    {
        head = new Node (data);
        tail = head;
    }
    bool isEmpty()
    {
        if (head == NULL)
        {
            return true;
        }
        return false;
    }
    //Insert at tail
    void InserAtTail(int data)
    {
        //implement yourself
        if (isEmpty())
        {return;}
        
        Node * temp = new Node(data);
        tail->next = temp;
        temp->prev = tail;
        tail = tail->next;
    }
    void InsertAtHead(int data)
    {
        //implement yourself
        if (isEmpty())
        {return;}
        Node *temp = new Node (data);
        temp->next = head;
        head->prev = temp;
        head = temp;
    }
    void Insert_atSpecificLoc(int data, int loc)
    {
        if (isEmpty())
        {return;}
        if (loc <= 0)
        {
            InsertAtHead(data);
            return;
        }
        Node * temp = head;
        int index = 0;
        while(temp->next != tail && index < loc-1)   // agr  list end tk nhi pohanchi and index jo user ne loc di ha loc -1 se less ha phr ye loop chaly gi
        {
            temp = temp->next;
            index ++;
        }
        if (loc-1 > index)
        {
            InserAtTail(data);
            return;
        }
        Node * newnode = new Node(data);
        newnode->next = temp->next;
        //temp->next->prev = newnode (wrong logic ku ka ab temp kay next waly node ka temp kay sath connection break ho chuka ha)
        newnode->next->prev = newnode;
        temp->next = newnode;
        newnode->prev = temp;
    }
    void Display()
    {
         if (isEmpty())
        {return;}
        Node * temp = head;
        while (temp!=NULL)
        {
            cout <<"<-" << temp->data << "->" ;
            temp = temp->next;
            
        }
        cout << endl;
    }
    void ReverseDisplay()
    {
         if (isEmpty())
        {return;}
        Node * temp = tail;
        while (temp!=NULL)
        {
            cout <<"<-" << temp->data << "->" ;
            temp = temp->prev;
            
        }
        cout << endl;
    }
    void DeleteAtHead()
    {
        //deal with single node
        if (isEmpty())
        {return;}
        Node * temp = head;
        head = head->next;
        head->prev = NULL;
        delete temp;
    }
    void DeleteAtTail()
    {
        //deal with single node
        if (isEmpty())
        {return;}
        tail = tail->prev;
        delete tail->next;
        tail->next = NULL;
    }
    void Delete_atSpecificLoc(int loc)
    {
        if (isEmpty())
        {return;}
        if (loc == 0)
        {
            DeleteAtHead();
            return;
        }
        Node * temp = head;
        int index = 0;
        while(temp->next != tail && index < loc-1)
        {
            temp = temp->next;
            index ++;
        }
        if (temp->next==tail)
        {
            DeleteAtTail();
            return;
        }
        Node * temp2 = temp->next;
        temp->next = temp2->next;
        temp2->next->prev = temp;
        delete temp2;
    }
 void deleteMiddleNode() {
        if (head == nullptr || head->next == nullptr || head->next == tail) {
            cout << "List is too short to have a middle node!" << endl;
            return;
        }
        
        Node* start = head;
        Node* end = tail;
        
        while (start != end && start->next != end){
            start = start->next;
            end = end->prev;
        }
        
        // Deleting the middle node
        Node* middle = start->next;
        start->next = middle->next;
        if (middle->next != nullptr)
            middle->next->prev = start;
        delete middle;
    }
void insert_atMiddle(int data){
    if (head == nullptr || head->next == nullptr || head->next == tail) {
        cout << "List is too short to have a middle node!" << endl;
        return;
    }

    Node* start = head;
    Node* end = tail;

    while (start != end && start->next != end){    //this loop will run until start is not equal to end(start = end) start = end at the middle of the linked list
        start = start->next;
        end = end->prev;
    }

    // Inserting the new node at the middle
    Node* middle = start->next;
    Node* newnode = new Node(data);
    newnode->next = middle;
    middle->prev = newnode;
    newnode->prev = start;
    start->next = newnode;
}
void swaphead(){
//	Node *temp = head->next;
//	head->next = temp->next->prev;
//	temp->next->prev = head;
//	temp->next = head;
//	head->prev = temp;
//
//	cout << "head->data" << head->data;
//	cout << "temp->data" << temp->data;
Node *temp = head;
      head = temp->next;
      Node *temp2 = head;
      temp = head;
   
       
  
    cout << "head->data: " << head->data << endl;
    cout << "temp->data: " << temp->data << endl;
	
}
void printheadData(){
	cout << head->data;
}
  
};
int main()
{
    DoublyLinkedList dl (4);
    
    dl.InserAtTail(5);
    dl.InsertAtHead(9);
    dl.Display();
    dl.Insert_atSpecificLoc(3, 0);
    dl.Insert_atSpecificLoc(1, 5);
    dl.Insert_atSpecificLoc(2, 4);
    dl.Display();   
    //dl.ReverseDisplay();
    cout << "Delete.\n\n";
    dl.Delete_atSpecificLoc(4);
    dl.Display(); 
    dl.DeleteAtHead();
    dl.Display(); 
    dl.DeleteAtTail();
    dl.Display(); 
    dl.InsertAtHead(13);
    dl.InsertAtHead(10);
    dl.InsertAtHead(11);
    
    dl.Display();
    dl.deleteMiddleNode();
    dl.Display();
    dl.insert_atMiddle(12);
    dl.Display();
    dl.insert_atMiddle(14);
    dl.Display();
    dl.swaphead();
   
    return 0;
}
                           </code></pre>
                       </div>
                       <h2 class="my-3">Second Method</h2>
                        <div class="code-container mt-2">
                            <div> 
                                <div style="position: realtive; transition: 2s ease;" class="d-none copiedMessage">
                                    <p  style="position: absolute; left: 40%; padding: 10px;clip-path: polygon(0% 15%, 0 0, 15% 0%, 85% 0%, 100% 0, 100% 15%, 100% 85%, 85% 85%, 63% 86%, 53% 100%, 42% 86%, 0% 85%); background-color: rgba(111, 44, 244, 0.603); color: white; border-radius: 5px;" >Copied!</p>
                                </div>
                                <div style="position: realtive; transition: 2s ease;" class="d-none notCopiedMessage">
                                    <p  style="position: absolute; left: 40%; padding: 10px;clip-path: polygon(0% 15%, 0 0, 15% 0%, 85% 0%, 100% 0, 100% 15%, 100% 85%, 85% 85%, 63% 86%, 53% 100%, 42% 86%, 0% 85%); background-color: rgba(205, 22, 22, 0.427); color: white; border-radius: 5px;" >Not Copied!</p>
                                </div>
                              <i class='bx bx-copy text-dark bg-light p-2 rounded' id="copyIcon8"></i>
                              <i class='bx bx-moon text-dark bg-light p-2 rounded lightDarkIconForCode' id="lightDarkIcon8"></i>
                            </div>
                            <pre class="mt-2">
                              <code class="language-cpp" id="SimpleNodeCode8">
#include &lt;iostream&gt;   
using namespace std;
class DoubleLinkedList{
	private: 
	    class Node{
	    	public:
	    		int data;
	    		Node* next;
	    		Node* prev;
	    		Node(int data){
	    			this->data = data;
	    			next = prev = NULL;
				}
		};
		Node *head;
		Node *tail;
	public: 
	    DoubleLinkedList(int data){
	    	head = new Node(data);
	    	tail = head;
		}
		void insert_atHead(int data);
		void insert_atTail(int data);
		void insert_atSpecificNode(int data,int loc);
		void delete_atHead();
		void delete_atTail();
		void delete_SpecificNode(int loc);
		void displayDoublyLL();
		void displayDoublyLL_reverse();
		int count();
		
};
int DoubleLinkedList::count(){
	int count = 1;
	Node *temp = head;
    while(temp->next != NULL){
    	temp = temp ->next;
    	count++;
	}
	return count;
}
void DoubleLinkedList::insert_atHead(int data){
	Node *newnode = new Node(data);
	newnode->next = head;
	head->prev = newnode;
	head = newnode; 
	head->prev = NULL;
	 
}
void DoubleLinkedList::insert_atTail(int data){
	Node * newnode = new Node(data);
	tail->next = newnode;
	newnode->prev = tail; // newnode->prev = tail->next (wrong) place tail(node) at the previous of newnode
	tail = tail->next;  // move tail one step forward
	tail->next = NULL;
}
void DoubleLinkedList::insert_atSpecificNode(int data,int loc){
	if(loc <= 0){
		DoubleLinkedList::insert_atHead(data);
		return;
	}
	int count = 0;
	Node *temp = head;
	Node *prev;
    while(temp != tail || temp == NULL) {
		if(loc == count){
			Node *newnode = new Node(data);
			newnode->next = temp->prev->next;
			temp->prev->next = newnode;
			newnode->prev = temp->next;
		}
	
		prev = temp;
		temp = temp->next;
		count++;
		
	}
	if(loc > count){
		DoubleLinkedList::insert_atTail(data);
		return;
	}
}
void DoubleLinkedList::delete_atHead(){
	Node *temp = head;  
	head = head->next;
	delete temp;
	head->prev = NULL;
}
void DoubleLinkedList::delete_atTail(){
	Node *temp = tail;     
	tail = tail->prev;
	delete temp;          // delete temp->next
	tail->next = NULL;
	
}
void DoubleLinkedList::delete_SpecificNode(int loc)
    {
        if (loc <= 0)
        {
            DoubleLinkedList::delete_atHead();
            return;
        }
        Node * temp = head;
        int index = 0;
        while(temp->next != tail && index < loc-1)
        {
            temp = temp->next;
            index ++;
        }
        if (temp->next==tail)
        {
            DoubleLinkedList::delete_atTail();
            return;
        }
        Node * temp2 = temp->next;
        temp->next = temp2->next;
        temp2->next->prev = temp;
        delete temp2;
}
void DoubleLinkedList::displayDoublyLL(){
	Node *temp = head;
	
	while(temp != tail){
		cout << temp->data << " ";
		temp = temp->next;
	}
	cout << temp->data << " ";
	cout << endl;
}
void DoubleLinkedList::displayDoublyLL_reverse(){
	Node *temp = tail;
	while(temp != head){
		cout << temp->data << " ";
		temp = temp->prev;
	}
	cout << temp->data << " ";
	cout << endl;
}
int main(){
	cout << "Insert at head\n";
	DoubleLinkedList dll(0);
	dll.insert_atHead(1);
	dll.insert_atHead(2);
	dll.insert_atHead(3);
	cout << "Display Doubly Linked List\n";
	dll.displayDoublyLL();
	cout << "Display Doubly Linked List in reverse order\n";
	dll.displayDoublyLL_reverse();
	cout << "Insert at Tail\n";
	dll.insert_atTail(4);
	dll.insert_atTail(5);
	dll.insert_atTail(6);
	dll.insert_atTail(7);
	cout << "Display Doubly Linked List\n";
	dll.displayDoublyLL();
	cout << "Display Doubly Linked List in reverse order\n";
	dll.displayDoublyLL_reverse();
	cout << "Delete at head\n";
	dll.delete_atHead();
	cout << "Delete at head\n";
	dll.delete_atHead();
    cout << "Display Doubly Linked List\n";
	dll.displayDoublyLL();
	cout << "Display Doubly Linked List in reverse order\n";
	dll.displayDoublyLL_reverse();
	cout << "Delete at tail\n";
	dll.delete_atTail();
	cout << "Delete at tail\n";
	dll.delete_atTail();
    cout << "Display Doubly Linked List\n";
	dll.displayDoublyLL();
	cout << "Now checking of insert by user choice\n";
	cout << "Insert 3 at 1st index\n";
	dll.insert_atSpecificNode(3,1);
	dll.displayDoublyLL();
	cout << "Insert 7 at 5th position\n";
	dll.insert_atSpecificNode(7,5);
	dll.displayDoublyLL();
	
	cout << "Insert 8 at 7th position\n";
	dll.insert_atSpecificNode(8,7);
	dll.displayDoublyLL();
	
	cout << "Insert 6 at 4th position\n";
	dll.insert_atSpecificNode(6,4);
	dll.displayDoublyLL();
		
	dll.delete_SpecificNode(1);
    cout << "Display Doubly Linked List\n";
	dll.displayDoublyLL();
	
	cout << "Delete at position 0\n";
	dll.delete_SpecificNode(0);
    cout << "Display Doubly Linked List\n";
	dll.displayDoublyLL();
	
	cout << "Delete at position -1\n";
	dll.delete_SpecificNode(-1);
    cout << "Display Doubly Linked List\n";
	dll.displayDoublyLL();
	
	cout << "Delete at postion 4\n";
	dll.delete_SpecificNode(4);
    cout << "Display Doubly Linked List\n";
	dll.displayDoublyLL();
	
		cout << "Delete at postion 7\n";
	dll.delete_SpecificNode(7);
    cout << "Display Doubly Linked List\n";
	dll.displayDoublyLL();
	return 0;
}
    
                              </code>
                            </pre>
                          </div>
                          
                    </div>
                <div class="mt-2">
                    <h2 class="my-3">Recursive Approach</h2>
                    <div class="code-container">
                        <div>
                            <div style="position: realtive; transition: 2s ease;" class="d-none copiedMessage">
                                <p  style="position: absolute; left: 40%; padding: 10px;clip-path: polygon(0% 15%, 0 0, 15% 0%, 85% 0%, 100% 0, 100% 15%, 100% 85%, 85% 85%, 63% 86%, 53% 100%, 42% 86%, 0% 85%); background-color: rgba(111, 44, 244, 0.603); color: white; border-radius: 5px;" >Copied!</p>
                            </div>
                            <div style="position: realtive; transition: 2s ease;" class="d-none notCopiedMessage">
                                <p  style="position: absolute; left: 40%; padding: 10px;clip-path: polygon(0% 15%, 0 0, 15% 0%, 85% 0%, 100% 0, 100% 15%, 100% 85%, 85% 85%, 63% 86%, 53% 100%, 42% 86%, 0% 85%); background-color: rgba(205, 22, 22, 0.427); color: white; border-radius: 5px;" >Not Copied!</p>
                            </div>
                            <i class='bx bx-copy text-dark bg-light p-2 rounded' id="copyIcon9"></i>
                            <i class='bx bx-moon text-dark bg-light p-2 rounded lightDarkIconForCode' id="lightDarkIcon9"></i>
                        </div>
                       <pre class="mt-2"><code class="language-cpp" id="SimpleNodeCode9">
#include &lt;iostream&gt;
using namespace std;
class Recursive_DoubleLL{
    private:
        class Node{
            public:
                int data;
                Node *next;
                Node *prev;
                Node(int data){
                    this->data  = data;
                    next = NULL;
                    prev = NULL;
                }
        };
        Node *head;
        Node *tail;
    public:
        Recursive_DoubleLL(){
            head = NULL;
            tail = NULL;	
        }
        void insertATHead(int data){
                Node* newnode = new Node(data);
        if (head == NULL) {
            head = newnode;
            tail = newnode;
        } else {
            newnode->next = head;
            head->prev = newnode;
            head = newnode;
        }
        }
        bool isEmpty(){
            return(head == NULL && tail == NULL);
        }
        void insertAtTail_Rec(Node* node,int data){
            if(isEmpty()){
                insertATHead(data);
                return;
            }
            if(node == NULL){
                Node *newnode = new Node(data);
                tail->next = newnode;
                newnode->prev = tail;
                tail = newnode;
                return;
            }
            insertAtTail_Rec(node->next,data);
        }
        void insertAatTail_Wrapper(int data){
            insertAtTail_Rec(head,data);
        }
        void display_DLL_Rec(Node *node){
            if(node == NULL){
                cout << "NULL";
                cout << endl;
                return;
            }
            if(node == head){
                cout << "NULL";
            }
            cout << "<-" << node->data << "->"; 
            
            display_DLL_Rec(node->next);
        }
        void displayWrapper(){
            display_DLL_Rec(head);
        }
        void deleteAtHead(){
            if(isEmpty()){
                cout << "Linked List is empty\n";
                return;
            }
            if(head->next == NULL && head->prev == NULL){
                delete head;
                head == NULL;
            }
            head = head->next;
            delete head->prev;
            head->prev = NULL;
        }
        void deleteAtTail_Rec(Node *node){
            if(isEmpty()){
                cout << "Linked List is already empty\n";
            }
            if(head->next == NULL && head->prev == NULL){
                delete head;
                head == NULL;
            }
            if(node == NULL){
                Node *temp = tail;
                tail = tail->prev;
                tail->next = NULL;
                delete temp;
                
                return;
            }
            deleteAtTail_Rec(node->next);
        }
        void deleteAtTail_Wrapper(){
            deleteAtTail_Rec(head);
        }
        void insertAtMiddle(Node *start,Node *end,int data){
            if(countWrapper()% 2 == 0){
                    cout << "Nodes are even.Insertion for even no of nodes will handle later\n";
                    return;
                }
            if(start == end){
                start = start->prev;
                Node* middle = start->next;
                Node* newnode = new Node(data);
                newnode->next = middle;
                middle->prev = newnode;
                newnode->prev = start;
                start->next = newnode;
    
                return;   
                
            }
            insertAtMiddle(start->next,end->prev,data);
        }
        void insertAtMiddle_Wrapper(int data){
            insertAtMiddle(head,tail,data);
        }
        void deleteAtMiddle(Node* start,Node *end){
                if(countWrapper()% 2 == 0){
                    cout << "Two Middles are present so first make count of nodes odd\n";
                    return;
                }
            if(start == end && start->next != end){
            
                start = start->prev;
                Node* middle = start->next;
                start->next = middle->next;
                if (middle->next != nullptr)
                middle->next->prev = start;
                delete middle;
                return;
            }
            deleteAtMiddle(start->next,end->prev);
        }
        void deleteAtMiddle_Wrapper(){
            deleteAtMiddle(head,tail);
        }
        int countNodes(Node *node,int count = 1){
            if(isEmpty()){
                cout << "Count is 0\n";
            }
            if(node->next == NULL){
                return count;
            }
            
                countNodes(node->next,count + 1);	
        }
        int countWrapper(){
        
            countNodes(head);
        }
        
        //--------------------------------Correct Method----------------------
//	void deleteAllRecursive(Node* current) {
//    if (current == nullptr)
//        return;
//    deleteAllRecursive(current->next);
//    delete current;
//}
//
//void deleteWrapper() {
//    deleteAllRecursive(head);
//    head = nullptr; // Reset the head pointer after deleting all nodes
//    tail = nullptr;
//}


//------------------------------Correct Method---------------------
    void deleteAllRecursive(Node* current,Node *temp) {
    if (current == nullptr){
        
    
        return;
    }
        delete temp;
    deleteAllRecursive(current->next,current);
}

void deleteWrapper() {
    deleteAllRecursive(head,nullptr);
    head = nullptr; // Reset the head pointer after deleting all nodes
    tail = nullptr;
}
};
int main(){
    Recursive_DoubleLL rdll;
    rdll.insertATHead(1);
    rdll.insertATHead(2);
    rdll.insertATHead(3);
    rdll.insertATHead(4);
    rdll.displayWrapper();
    rdll.insertAatTail_Wrapper(5);
    rdll.insertAatTail_Wrapper(6);
    rdll.insertAatTail_Wrapper(7);
    rdll.insertAatTail_Wrapper(8);
    rdll.displayWrapper();
    rdll.deleteAtHead();
    rdll.displayWrapper();
    rdll.deleteAtTail_Wrapper();
    rdll.displayWrapper();
    rdll.insertAatTail_Wrapper(9);
    rdll.displayWrapper();
    //rdll.insertAtMiddle_Wrapper(10);
    //rdll.displayWrapper();
    cout << "Delete AT Middle\n";
    rdll.deleteAtMiddle_Wrapper();
    rdll.displayWrapper();
    cout << "Insert 10 and 11 at tail\n";
    rdll.insertAatTail_Wrapper(10);
    rdll.insertAatTail_Wrapper(11);
    rdll.displayWrapper();
    cout <<	"No of nodes in the linked list are\n" << rdll.countWrapper();
    cout << endl;
    cout << "Now check delete at middle for the even nodes\n";
    rdll.deleteAtMiddle_Wrapper();
    rdll.insertAatTail_Wrapper(13);
    rdll.displayWrapper();
    rdll.insertAatTail_Wrapper(14);
    rdll.displayWrapper();
    rdll.insertAtMiddle_Wrapper(12);
    rdll.displayWrapper();
    cout << "Delete Double Linked list\n";
    rdll.deleteWrapper();
    rdll.displayWrapper();
    if(rdll.isEmpty()){
        cout << "Linked list is empty\n";
    }
    else {
        cout << "No Empty\n";
    }
    
    
    return 0;
}
                       </code></pre>
                   </div>   
                </div>
            </div>
            </div>
        </div>
        <script>loadContent('footer.html', 'footer');</script>
        <div id="footer"></div>
        <script>loadContent('Up.html', 'quickUp');</script>
        <div id="quickUp"></div>
        <script src="js/searchFunctionlity.js"></script>
        <script src="dist/up.js"></script>
        <script src="dist/codeFunctionality.js"></script>
        <script src="dist/index.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/cpp.min.js"></script>
        <script>hljs.highlightAll();</script>
</body>
</html>